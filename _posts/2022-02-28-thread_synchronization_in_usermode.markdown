---
layout: post
title:  "유저 모드에서의 스레드 동기화"
date:   2022-02-28 12:12:59 +0900
categories: Windows
---

### 아토믹 연산

Interlocked 함수들이 있다.<br>
원자적으로 값을 다루는 함수들.<br>
동작 방식은 CPU 플랫폼마다 다르다.<br>
**유저모드와 커널모드의 전환도 발생시키지 않는다.**<br>
보통 전환시에는 1000사이클 이상이 필요한데 인터락 함수는 보통 50 사이클 보다 작다고 책에 나와있다.<br>
인터락 싱글 링크드 리스트 함수가 있다.<br>
```
InitializeSListHead
interlockedPushEntrySList
InterlockedPopEntrySList
InterlockedFlushSList
QueryDepthSList
```


### 캐시 라인

CPU가 메모리로부터 값을 가져올때는 캐시 라인을 채울 만큼 한 번에 가져온다.<br>
32바이트(옛날 cpu), 64바이트, 128바이트 크기로 구성되며(cpu마다 다르다. 최근의 인텔 cpu는 L1, L2, L3 모두 64바이트 인것 같다.) 해당 바이트 경계로 정렬되어 있다.<br>
CPU1이 캐시 라인에 있는 정보를 변경하면 CPU2의 캐시 라인에 있던 정보는 모두 무효화된다.(기존에 들고 있던 잘못된 정보로 연산 하면 안되니까)<br>
`GetLogicalProcessorInformation` 함수를 이용하면 캐시 라인 크기를 가져올 수 있다.<br>
`__declspec(align(#))` 지시어를 사용해서 정렬 할 수 있다.<br>



### volatile

타입 한정자
컴파일러에게 이 변수가 운영체제나 하드웨어 혹은 다른 스레드같이 외부에서 값을 변경 할 수 있음을 알려주는 역할.<br>
volatile 타입 한정자가 지정되면 컴파일러는 이 변수에 대해서 어떠한 최적화도 수행하지 않으며, 값이 참조될 때 항상 메모리로부터 값을 다시 가지고 오도록 코드를 생성한다.<br>
**변수의 주소를 함수에 전달하게 되면 함수는 항시 메모리로부터 값을 얻어오게 되며, 최적화 기능은 이에 영향을 주지 않게 된다.**<br>


### 크리티컬 섹션

내부적으로 인터락 함수를 사용하고 있기 때문에 매우 빠르게 동작함.<br>
다른 스레드가 이미 접근 권한을 힉득한 상태라면 `EnterCriticalSection` 을 호출한 스레드를 이벤트 커널 오브젝트를 이용해서 대기 상태로 만든다.<br>
크리티컬 섹션은 지정된 시간이 만료되는 경우 예외를 발생시키게 되어있다. 레지스트리에 기본 값으로 2592000을 가지고 있다. 대략 30일 정도. <br>
스레드가 대기 상태로 변경될때 유저 모드에서 커널 모드로 전환되야 하는데 이는 매우 비싼 동작이다. <br>
그래서 `EnterCriticalSection` 을 호출 하면 일정 횟수 스핀락을 사용해서 리소스 획득을 시도한다. <br>
아주 드물게 `InitializeCriticalSection` 함수도 실패할 수 있음. 내부적으로 디버깅 정보를 저장하기 위한 메모리 블록을 할당 하기 때문. <br>
STATUS_NO_MEMORY 예외를 발생. `InitializeCrtiticalSectionAndSpinCount` 함수는 실패시 `FALSE` 를 리턴한다. <br>
가용메모리가 부족해서 이벤트 커널 오브젝트를 생성하지 못하는 경우도 있음. <br>
이 경우 `EnterCriticalSection` 에서 `EXCEPTION_INVALID_HANDLE` 예외를 발생시킨다. <br>
예방하는 방법으로는 `InitializeCriticalSectionAndSpinCount` 를 사용하여 dwSpinCount 매개변수의 최상위 비트를 설정하면 앞으로 필요할지 모르는 이벤트 커널 오브젝트를 초기화 시점에 미리 만들어 둔다. <br>
윈도우xp 부터는 가용 리소스가 매우 적은 상태에서 발생할 수 있는 이벤트 생성 문제를 해결하기 위해 키 이벤트(key event) 라는 새로운 커널 오브젝트가 추가되었다.<br>
가용메모리가 거의 없고, 이벤트 커널 오브젝트 생성이 불가능할 경우 이 키 이벤트를 사용해 블록킹을 수행한다. <br>



### SRWLock 슬림 리더-라이터 락

크리티컬 섹션과의 차이는 읽기만 하는 스레드와 수정하는 스레드를 구별해서 사용 할 수 있다는것. <br>
앞서 나와있던 동기화 객체들 + 뮤텍스간 속도 비교시 volatile > Interlocked > SRWLock > 크리티컬섹션 순으로 성능이 나온다. <br>


### 동기화 객체 사용 팁(?)

원자적으로 관리되어야 하는 오브젝트 집합당 하나의 락만을 사용하라. <br>
락을 장시간 점유하지 마라. <br>
