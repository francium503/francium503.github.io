
---
layout: post
title:  "실행 시점과의 연관성"
date:  2022-06-24 21:36:59 +0900
categories: Csharp CLR
---


<br>
<br>
이부분은 타입, 객체, 스레드, 스택, **관리되는** 힙의 관계 및 static/instance/virtual 메서드 사이의 차이점에 대해서 간단(?)하게 정리를 하고 가는 시간이 될거같다. <br>
<br>
<br>
새로운 스레드를 만들때 스레드당 1MB 사이즈의 스택이 할당된다. <br>
스택이 사용되는 용도도 지역변수를 보관하거나, 함수 콜 간의 매개변수 전달에 사용되는것도 똑같다.<br>
<br>
이제 CLR에서 다음과 같은 코드가 있을때 동작하는 내용에 대해서 정리를 해보겠다. <br> 
```c#
internal class a {
  public         Int32 getInt() { ... }
  public virtual String getString() { ... }
  public static  a getA() { ... }
}

internal sealed class b : a {
  public override String getString() { ... }
}
```
<br>
이떄 저 클래스를 초기화하고 함수를 호출하는 메서드의 코드가 동작한다고 가정해보자. <br>
```c#
void foo() {
  a var;
  Int32 i;
  var = new b();
  var = getA();
  i = var.getInt();
  var.getString();
}
```
<br>
우선 JIT 컴파일러가 호출하는 메서드의 IL 코드를 네이티브 명령어로 컴파일한다.<br>
이때 타입정보등에 필요한 것들은 힙에 올라가게 된다. <br>
위 코드에서는 class a 와 class b 에 대한 타입 정보가 될것이다. <br>
힙 위에 만들어지는 모든 객체들은 타입 객체 포인터와 동기화 블록 인덱스를 가지게 된다. <br>
그리고 타입을 선언할 떄 정적 필드를 포함할 수도 있따. 이 정적 필드의 할당에 소요되는 메모리는 해당 타입 객체가 만들어지는 시점에 할당된다.<br>
<br>
그리고 타입내의 메서드 하나 당 한개의 항목이 포함된 메서드 테이블도 만들어지게 된다. <br>
<br>
이것들을 모두 만들고 나면 실행 될 준비가 된다. <br>
<br>
c#에서는 한번 만드는 과정을 거친 코드에 대해서는 빠르게 지우지 않아서 JIT 컴파일러를 사용하더라도 JIT으로 돌아가니까 무작정 느릴꺼라는 생각보다는 빠르다. <br>
<br>
<br>
아무튼 메서드의 컴파일이 완료되고 모든 타입 객체가 있으면 이제 실행 될 수 있다. <br>
c#에서는 프롤로그 코드에서 모든 지역변수를 null 과 0 으로 초기화한다. <br>
<br>
이후 각 객체가 호출하게 된다면 자동으로 스택에 타입 객체 정보들을 가지고 새로운 객체를 만들어 반환한뒤 해당 주소의 포인터를 스택에 저장한다. <br>
( var 를 만드는 과정 ) <br>
스택의 var 가 힙에 있는 객체를 가르키고 해당 객체는 b를 가르키게 되는 형식. <br>
이후 getA()가 호출되게 되면, JIT컴파일러는 getA()에 대해서 컴파일을 한다. <br>
컴파일을 한 후, 실행되어 어딘가에서 만들어지거나 이미 만들어져있던 객체를 리턴해 var에 연결하게 된다. <br>
이후 getInt()를 호출하게 된다. <br>
JIT컴파일러는 역시 비가상 함수인 getInt의 호출에 사용할 정확한 타입을 찾아 호출하게 된다. <br>
(대략 b로 만들어졌지만 a의 함수 getInt()를 정상적으로 잘 찾아서 호출한다는 내용)<br>
이후, getString()를 호출할때는 변수의 형태를 먼저 확인하고 정확한 함수를 호출한다. <br>
즉, JIT컴파일러가 a의 getString()을 컴파일해 실행하는것이 아닌 b의 getString()을 컴파일해 실행한다. <br>
<br>
이게 c++ 가상함수 테이블을 사용하는 과정이 c#으로 넘어와서 CLR에서 대략적인 클래스와, 여러 종류의 함수들의 작동 방법이다. <br>
<br>
<br>
이미 c++에서의 가상함수 동작을 알고 있었던 입장으로써는, <br>
크게 다른것은 없고, <br>
JIT컴파일러에 의해 컴파일 하기전 타입을 찾아서 컴파일 한다. <br>
호출되는 메서드에 대해서만 컴파일 되어있다. <br>
타입객체정보를 힙에 들고있다. <br>
기본적으로는 NULL과 0 으로 초기화가 자동으로 된다.<br>
<br>
(기존 c++도 vs의 디버그 모드에서는 vs가 해줬지만,)<br>
<br>
정도를 잘 짚고 넘어가면 될것 같다. <br>
<br>
<br>






