---
layout: post
title:  "윈도우 스레드 스케줄링"
date:   2022-02-28 11:16:59 +0900
categories: Windows
---

요즘 제프리 리처의 Windows via C/C++ 라는 책을 보고 있다.

공부 할 겸 중요해 보이는 내용을 잊지 않게 블로그에 포스트를 하나씩 추가 해볼려고 한다.

VOID Sleep(DWORD dwMilliseconds); 함수에 대해서

호출시 남은 타임 슬라이스를 자발적으로 포기
시스템은 지정된 시간 동안 스레드를 스케줄 불가능 상태로 유지 - 하지만 윈도우는 실시간 운영체제가 아니여서 더 많은 시간 동안 불가능 상태로 유지 될 수 있음.
매개변수로 INFINITE 를 전달할 수 있다. 하지만 별로 유용하지 못함.
0을 전달시 남은 타임 슬라이스를 포기하고 다른 스레드를 스케줄하게 한다. 그런데 시스템에 우선순위가 높거나 같은 스레드 중에 스케줄 가능한 스레드가 없을 경우 바로 다시 스케줄 될 수 있다.


스케줄 가능 상태에 있는 다른 스레드를 수행 하기 위한 함수로
BOOL SwitchToThread();
함수가 존재한다.


일정시간 CPU 시간을 받지 못해서 수행되지 못한 스레드가 없으면 바로 반환 되지만 있으면 해당 스레드를 스케줄한다.
단일 퀀텀타임동안 수행하며 이후 이전과 동일하게 스케줄링을 수행한다.
Sleep(0)과 비슷하지만 SwitchToThread의 경우 더 낮은 우선순위의 스레드도 수행 될 수 있다는 점이 차이


CONTEXT 구조체
CONTEXT_CONTROL 영역 - 인스트럭션 포인터, 스택포인터, 플래그, 함수 반환 주소 등의 CPU 제어 레지스터 값
CONTEXT_INTEGER 영역 - CPU의 정수 레지스터 값
CONTEXT_FLOATING_POINT 영역 - CPU의 부동소수점 레지스터 값
CONTEXT_SEGMENTS 영역 - CPU의 세그먼트 레지스터 값
CONTEXT_DEBUG_REGISTERS 영역 - CPU의 디버그 레지스터 값
CONTEXT_EXTENDED_REGISERS 영역 - CPU의 확장 레지스터 값


스레드 우선순위

모든 스레드는 0부터 31의 우선순위를 가짐
각 타임 슬라이스가 끝나면 31부터 스케줄 가능한 스레드가 있는지 확인하면서 해당 스레드를 CPU에 할당
31번 우선순위를 가진 스레드가 스케줄 가능한 상태에 있는 동안은 0부터 30번 우선순위를 가진 스레드는 절대 CPU 시간을 할당받지 못한다. 이 상태가 기아 상태(starvation)
시스템이 부팅되면 제로 페이지 스레드 라고 불리는 특별한 스레드가 생성됨. 이 스레드는 시스템 전체에서 0번 우선순위를 가진 유일한 스레드.
제로 페이지 스레드는 시스템 전체에서 다른 어떤 스레드도 스케줄 가능한 상태가 아닐때 램의 사용되지 않는 페이지를 0으로 만들어주는 작업을 수행함
실시간 보다 낮은 우선순위에서는 15가 최대임
실시간에서는 16보다 낮은 우선순위를 가지지 않음
17,18,19,20,21,27,28,29,30 우선순위는 커널모드에서 수행되는 디바이스 드라이버를 작성할 때에만 사용된다.
*책에서는 비스타 기준으로 설명해서 자세한 수치는 따로 표시하지 않음


선호도
윈도우는 스레드를 프로세서에 할당할 때 소프트 선호도를 사용한다.
다른 모든 조건이 동일 할 때 마지막으로 스레드를 수행했던 프로세서가 동일 스레드를 다시 수행하도록 하는것.
이 경우 케시메모리에 있는 데이터를 재사용할 가능성이 있어서.
