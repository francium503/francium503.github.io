---
layout: post
title:  "기초 지식 정리"
date:   2022-03-10 21:23:59 +0900
categories: cpp Windows Network STL
---

한번 기초지식을 싹 정리 해 볼려고 생각하다가 결국 오늘 한다. <br>
<br>
<br>
윈도우는 리틀 엔디안 방식을 사용하고 있다. <br>
0x11223344 를 저장 하고자 할때 리틀 엔디안 에서 저장 방식은 0x44 33 22 11 순으로 저장한다.<br>
포인터로 캐스팅 했을때, short 면 0x 33 44 , char면 0x 44 를 읽는다. <br>
윈도우에서 32비트 기본 프로그램은 커널에서 램 2기가 유저모드에서 램 2기가를  사용 할 수 있다. <br>
유닉스 타임스탬프는 1970.01.01 00:00 부터 흐른 시간이다. <br>
`srand(seed)` 함수는 쓰레드 단위로 동작한다. <br>
seed 바탕으로 난수를 가져와서 `rand()`가 호출 될 때 마다 다음 난수를 불러온다. <br>
STL map은 래드블랙트리를 사용한다. <br>
고로 log n 시간 복잡도 이다. <br>
윈도우에서 시간 관련 함수로는 다음이 있다. <br>
`Clock_t clock();`<br>
`GetTickCount();`<br>
`timeGetTime();`<br>
`queryperformenceCounter();`<br>
구조체 기본 패딩은 4byte 단위로 잡혀있다.<br>
#pragma pack 등을 이용해서 수정 할 수 있다. <br>
워킹셋은 물리적으로 올라간 메모리다. <br>
오버로딩은 매개변수가 다른 함수, 오버라이딩은 부모 자식 간 상속 관계에서 재정의 이다. <br>
오버로딩은 리턴 타입으로 할 수 없다. 매개변수 갯수와 타입으로 가능하다. <br>
inline 함수는 선택적으로 함수로 만들어지지 않는다. <br>
VC 기준<br>
`Template<typename T>` 는 컴파일 시점에 생성된다. <br>
type 별로 따로 만드는걸 특수화 라고 한다. <br>
메모리 reserve는 64KB 단위다. <br>
Page 단위로 커밋된다. <br>
VC 어셈 창에서 `[8123h]` 는 delete 다. <br>
delete 는 null 체크를 한다. <br>
c++에서 클래스와 구조체는 큰 차이가 없다.<br>
기본 범위 한정자가 구초제는 public 이고, 클래스는 private다. <br>
멤버함수에 보이지 않게 this 포인터를 같이 넘긴다. <br>
enum 은 다른 타입이 와도 사용 가능하다. enum class 를 쓰면 해당 enum에 대해서 검사한다. <br>
클래스 전방 선언시 객체는 올 수 없지만 포인터는 가능하다. <br>
소멸자 호출 시점은 블럭의 끝이나 리턴시 이다. <br>
클래스 생성자 이니셜라이저는 const 변수, 객체등에 이유가 있다. <br>
원치 않는 형변환을 방지 하기 위해 `explicit` 키워드가 있다. <br>
mutable 키워드는 const 함수 내에서 변경 가능 하게 해준다. <br>
public 상속은 권한을 그대로, protected 상속은 public 을 protected로, private 상속은 전부 private다. <br>
가상함수 테이블은 클래스 별로 존재하고 최상위에 있다. <br>
상속시에는 소멸자에 virtual 키워드를 달아줘야 정상적으로 소멸자가 호출된다. <br>
throw 하면 catch 까지 나와진다. 이걸 stack unwinding 이라고 한다. <br>
utf-8에서 한글은 3바이트이다. <br>
스택은 쓰레드당 1개씩 생성된다. <br>
코드, 데이터, 힙영역은 프로세스 내에서 공유하는데 이게 쓰레드와 프로세스의 차이다. <br>
non paged pool 에는 커널, 드라이버 등에서 쓰는 메모리가 있다. <br>
이 부분은 pagefile로 안간다. <br>
OS 스케줄링은 쓰레드 단위로 된다. <br>
`__stdcall` 이랑 `__cdecl` 은 피호출자에서 정리, 호출자에서 정리 차이다. <br>
`__stdcall` 은 피호출자에서 정리해서 가변인자 함수를 만들수가 없다. <br>
`Sleep()` 함수에 0 을 넣고 호출하면 쓰레드를 대기상태로 전환시킨다. <br>
하지만 쓰레드 스케쥴링에 따라 바로 다시 돌아올 수 있다.<br>
`SwitchToThread()` 는 쓰레드 전환 후 나보다 우선순위가 낮아도 실행한다. <br>
ARP 패킷은 LAN 범위 안에서 브로드 캐스팅 한다. <br>
LAN에 없으면 게이트웨이로 던져서 찾는다. <br>
127.0.0.1 은 메모리에서 돈다. <br>
UDP 에서 패킷 손실은 장비등에서 버퍼 부족할 때 나타난다. <br>
TCP 연결은 ip,포트 맵핑이다. <br>
TCP_NODELAY 로 네이글 알고리즘을 끌 수 있다. <br>
Accept 하기 전 대기 하는곳이 백로그 큐라고 하는데 윈도우에서 기본 크기가 200이다.<br>
백로그 큐가 꽉 찼을때 accept 안하면 connect가 실패 된다. <br>
리액터 패턴으로는 Select 모델이, 프로액터 모델로는 iocp 같이 비동기 작업등이 있다. <br>
작업 주체(?) 로 구별 할 수 있는거 같다. <br>
펑터는 operator()() 를 가진 함수 객체가 될 수 있다. <br>
대략 함수 포인터와 비슷하지만 조금 상위 개념이다. <br>
stl vector는 사이즈가 변경 될 때마다 새로 사이즈를 잡는다. <br>
at 과 []의 차이는 at은 범위 검사를 해서 예외를 throw 해준다. <br>
map 의 정렬 안된 버전으로 unordered_map 이 있다. <br>
os에서 강제적으로 퀀텀타임 기준으로 쓰레드를 중단시키는건 선점형이다. <br>
퀀텀타임 다씀, 내가 반환, io처리, 쓰레드 우선순위 높은 쓰레드가 올때 전환된다. <br>
멀티 쓰레드에 안전한 코드는 최소단위 오퍼레이션이다. <br>
asm 코드 대부분이 해당된다. <br>
atomic, interlocked 연산이 있다. <br>
ExitThread는 destructor 가 호출이 안된다. <br>
고로 쓰레드 종료는 return 을 유도 해야한다. <br>
ex가 붙는 함수들은 alertable wait 상태로 전환 될 수 있는 함수들이다. <br>
락프리 알고리즘은 멀티쓰레드에서 여러 쓰레드가 동시에 경쟁 및 실행된다. <br>
일반적인 쓰레드 세이프는 동시에 하지 않을 경우도 포함하지만 이건 퀀텀타임을 전부 사용함. <br>
context switch나 커널모드로 전환이 없다. <br>
성공할때 까지 재시도 한다. <br>
Atomic 하게 포인터를 관리해서 만듬.<br>
SRW락은 재귀 호출돌 경우 데드락이 걸릴 수 있다. <br>
이점이 CriticalSection과 다르다. <br>
<br>
<br>
<br>
<br>
<br>
일단 생각나는건 이정도 인거 같다..<br>
<br>
<br>














